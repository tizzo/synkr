// Generated by CoffeeScript 1.4.0
var config, options, request, watchr, winston;

var fs = require('fs'),
  watchr = require('watchr'),
  winston = require('winston');

var connection = require('./lib/ssh-connection');

var queue = [];
// Are we currently in the process of running the queue?
var queueProcessing = false;

connection.configure({
  host: '33.33.33.115',
  port: 22,
  username: 'vagrant',
  privateKey: require('fs').readFileSync('/Users/howard/Documents/Code/Node.js/rsync-watch/id_rsa')
});
connection.setLogger(winston);
connection.connect();

// Just requiring this allows us to use a yaml config
// file rather than JSON via require calls.
require('js-yaml');

// Load our configuration from the yaml file.
var config = require('./config');

// A local cache of directories that should be in a known-existent state.
var directoriesEnsured = [];

/**
 * Gets a flat array of configured paths to watch.
 */
var getPathsToWatchArray = function(config) {
  var paths = [];
  for (path in config.pathsToWatch) {
    paths.push(path);
  }
  return paths;
}

// The returned local path should include the leading slash.
var getLocalPath = function(filePath, conf) {
  var conf = findOptionDefinition(filePath);
  return filePath.substring(conf.localPath.length);
};

var findDirectoryPath = function(filePath, fileCurrentStat) {
  if (fileCurrentStat !== null && !fileCurrentStat.isDirectory()) {
    directoryToEnsure = filePath.split('/');
    directoryToEnsure.pop();
    directoryToEnsure = directoryToEnsure.join('/');
  }
  else {
    directoryToEnsure = filePath;
  }
  return directoryToEnsure
};

var createDirectory = function(changeType, filePath, fileCurrentStat, conf, done) {
  directoryToEnsure = findDirectoryPath(filePath, fileCurrentStat);
  directoryToEnsure = getLocalPath(directoryToEnsure);
  winston.info('trying to ensure ' + directoryToEnsure);
  if (directoriesEnsured.indexOf(directoryToEnsure) === -1) {
    // fileCurrentStat could be null because this is a deletion.
    var command = 'mkdir -p ' + conf.remotePath + directoryToEnsure;
    directoriesEnsured.push(directoryToEnsure);
    winston.info(command);
  }
  // TODO: Should we do this over sftp rather than exec?
  connection.exec(command, function(error, exitCode) {
    done(error, true);
  });
};

var syncFile = function(conf, changeType, filePath, fileCurrentStat, done) {
  buildSyncCommand(conf, changeType, filePath, conf);
  done(null, true);
};

var buildSyncCommand = function(conf, changeType, filePath, conf) {
  var options = conf.commandOptions.join(' ');
  var remoteSystem = conf.remoteUser + '@' + conf.remoteHost + ':' + conf.remotePort;
  command = conf.command + ' ' + options + ' ' + filePath + ' ' + remoteSystem + getRemotePath(filePath, conf);
  connection.transferFile(filePath, getRemotePath(filePath, conf), function() {
    winston.info('looks done.');
  });
};

var enqueueCommand = function(command, arguments) {
  queue.push([command, arguments]);
  if (!queueProcessing) {
    processQueue();
  }
}

var processQueue = function() {
  queueProcessing = true;
  while (item = queue.shift()) {
    item[0].apply(this, item[1] || []);
  }
  queueProcessing = false;
}

/**
 * Locate the option definition appropriate to this path.
 */
var findOptionDefinition = function(filePath) {
  var match = '';
  for (path in config.pathsToWatch) {
    searchPattern = '';
    if (filePath.search(searchPattern) == 0 && path.length > match) {
      match = path;
    }
  }
  if (match == '') {
    throw new Error('Invalid change path');
  }
  conf = config.pathsToWatch[match];
  conf.localPath = match;
  return conf;
};


var processChange = function(changeType, filePath, fileCurrentStat, filePreviousStat, conf) {
  winston.info(changeType, filePath);
  createDirectory(changeType, filePath, fileCurrentStat, conf, function(error, success) {
    if (error) {
      winston.error('Synchronization for ' + filePath + ' not completed because ensuring the directory exists was not possible.');
    }
    else if (!fileCurrentStat.isDirectory()) {
      syncFile(conf, changeType, filePath, fileCurrentStat, function(error, success) {
        winston.info('Synchronization complete');
      });
    }
  });
};

var changeHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat) {
  var conf = findOptionDefinition(filePath);
  if (changeType == 'create' || changeType == 'update') {
    createOrUpdateHandler(changeType, filePath, fileCurrentStat, filePreviousStat, conf);
  }
  else if (changeType == 'delete') {
    // deleteHandler(changeType, filePath, fileCurrentStat, filePreviousStat, conf);
    enqueueCommand(deleteHandler, [changeType, filePath, fileCurrentStat, filePreviousStat, conf]);
  }
  else {
    throw new Error('Invalid change type `' + changeType + '` on file `' + filePath + '`.');
  }
};

var getRemotePath = function(filePath, conf) {
  var remotePath = conf.remotePath;
  return remotePath + getLocalPath(filePath);
}

var deleteHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat, conf) {
  var localPath = getLocalPath(filePath);
  if (directoriesEnsured.indexOf(localPath) != -1) {
    directoriesEnsured.splice(directoriesEnsured.indexOf(localPath), 1);
  }
  if (filePreviousStat.isDirectory()) {
    connection.rmdir(getRemotePath(filePath, conf), function() {});
  }
  else {
    connection.delete(getRemotePath(filePath, conf), function() {});
  }
};

var createOrUpdateHandler = function(changeType, filePath, fileCurrentStat, filePreviousStat, conf) {
  var skip, type, i;
  skip = false;
  // TODO: Refactor to move exclusions into the
  for (i = 0; i < config.fileTypesToExclude.length; i++) {
    type = config.fileTypesToExclude[i];
    if (filePath.search("." + type) !== -1) {
      skip = true;
    }
    if (config.ignoreHiddenFiles && filePath.search(/\./) === 0) {
      skip = true;
    }
  }
  if (!skip) {
    enqueueCommand(processChange, arguments);
    winston.info(filePath + " " + changeType + "d.");
  }
};

connection.connection.on('ready', function() {
  watchr.watch({
    paths: getPathsToWatchArray(config),
    ignoreHiddenFiles: true,
    ignoreCommonPatterns: true,
    listeners: {
      change: changeHandler
    },
    next: function(err, watchers) {
      return winston.info(getPathsToWatchArray(config).join(', ') + " now watched for changes.");
    }
  });
  // connection.transferFile('/Users/howard/Desktop/samplefile.md', '/home/vagrant/somefile.md', function() {
  //   winston.info('transfer complete');
  // })
});
